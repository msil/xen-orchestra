import {
  every,
  forEach,
  isArray,
  isPlainObject,
  some,
} from 'lodash'

// ===================================================================

const { hasOwnProperty } = Object.prototype
const getSingleKey = obj => {
  let prop
  for (const key in obj) {
    if (hasOwnProperty.call(obj, key)) {
      if (prop !== undefined) {
        return
      }
      prop = key
    }
  }
  return prop
}

const OPERATORS = {
  __not: (pattern, value) => !match(pattern, value),
  __or: (pattern, value) => some(pattern, subpattern => match(subpattern, value)),
}

export const match = (pattern, value) => {
  if (isPlainObject(pattern)) {
    const key = getSingleKey(pattern)
    let operator
    if (key !== undefined && (operator = OPERATORS[key]) !== undefined) {
      return operator(pattern[key], value)
    }

    return isPlainObject(value) && every(pattern, (subpattern, key) => (
      value[key] !== undefined && match(subpattern, value[key])
    ))
  }

  if (isArray(pattern)) {
    return isArray(value) && every(pattern, subpattern =>
      some(value, subvalue => match(subpattern, subvalue))
    )
  }

  return pattern === value
}

// -------------------------------------------------------------------

const createPredicate = pattern => pattern == null
  ? () => false
  : value => match(pattern, value)

export const patch = (value, patchData) => {
  if (isPlainObject(patchData)) {
    if (isArray(value)) {
      const toRemove = createPredicate(patchData['-'])
      const tmp = []
      forEach(value, (v, i) => {
        if (i in patchData) {
          const p = patchData[i]
          if (p === null) {
            return
          }
          tmp.push(patch(v, p))
        } else if (!toRemove(v)) {
          tmp.push(v)
        }
      })
      const toAdd = patchData['+']
      if (toAdd) {
        tmp.push.apply(tmp, toAdd)
      }
      return tmp
    }

    if (isPlainObject(value)) {
      value = { ...value }
      forEach(patchData, (v, k) => {
        if (v === null) {
          delete value[k]
        } else {
          value[k] = patch(value[k], v)
        }
      })
      return value
    }

    value = {}
    forEach(patchData, (v, k) => {
      if (v !== null) {
        value[k] = patch(null, v)
      }
    })
    return value
  }

  return patchData
}
